# Type interfence

> `type interfence` - иногда можно не указывать анотацию типа, потому что `typescript` и так всегда следит за порядком и делает это...

> `TypeScript` достаточно умный, чтобы понять, что если переменной присваивается строковое значение `("John")`, её тип будет `string`, даже если мы явно его не указываем.

```ts
let userName = "John"; // Но рекомендуется конечно анотацию все же указывать
```

<!--! --------------------------------------------------------------------------------------------------- -->

### В каких случаях можно не указывать типы?

```ts
/*Инициализация переменной при объявлении:*/
let color = "blue"; // Тип автоматически будет string

/*Функции, которые возвращают значение на основе выражения:*/
function add(x: number, y: number) {
  return x + y; // Тип возвращаемого значения будет number
}

/*Простые массивы:*/
const fruits = ["apple", "banana", "orange"]; // Тип будет string[]

/*Использование функций обратного вызова (callback): Например, в методах массивов:*/
const numbers = [1, 2, 3];
const doubled = numbers.map((num) => num * 2); // Тип будет number[]
```

<!--! --------------------------------------------------------------------------------------------------- -->

### Когда лучше указывать типы явно?

- Сложные объекты или вложенные структуры:

```ts
type User = {
  name: string;
  address: {
    street: string;
    city: string;
  };
};

let user: User = {
  name: "Alice",
  address: { street: "Main St", city: "Wonderland" },
};
```

- Параметры и возвращаемые значения публичных функций:

```ts
function multiply(a: number, b: number): number {
  return a * b;
}
```

- Когда функция возвращает сложный тип или объект:

```ts
function createUser(name: string): { name: string; createdAt: Date } {
  return { name, createdAt: new Date() };
}
```
